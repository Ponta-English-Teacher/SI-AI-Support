<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SI AI Support</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2rem; background-color: #f4f4f4; color: #333; }
    h1 { margin-top: 0; }
    .section { margin-bottom: 2rem; padding: 1rem; background: #fff; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
    .section h2 { margin: 0 0 0.25rem; }
    .section .hint { margin: 0.25rem 0 0.75rem; color: #666; font-size: 0.95rem; }
    button { padding: 0.5rem 1rem; background-color: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; }
    button:hover { background-color: #2980b9; }
    textarea { width: 100%; height: 80px; margin-top: 0.5rem; padding: 0.5rem; border: 1px solid #ccc; border-radius: 5px; font-family: inherit; }
    .chat-box { margin-top: 1rem; background-color: #eef; padding: 1rem; border-radius: 5px; white-space: pre-wrap; }
    .popup { position: fixed; top: 80px; right: 24px; background: #fff; border: 1px solid #ccc; padding: 15px; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.2); display: none; max-width: 420px; z-index: 999; }
    .popup button { margin-top: 10px; }
    .glossary-table { width: 100%; margin-top: 30px; border-collapse: collapse; background: #fff; }
    .glossary-table th, .glossary-table td { border: 1px solid #ccc; padding: 8px; text-align: left; }
    .glossary-table th { background-color: #f0f0f0; }

    /* Dictionary improvements */
    #dictionaryPopup {
      max-height: 65vh;
      overflow: auto;
      resize: horizontal; /* allow user to widen it */
    }
    #dictWord {
      cursor: move;       /* drag handle */
      user-select: none;
      margin: 0 0 6px;
    }
  </style>
</head>
<body>
  <h1>SI AI Support ‚Äî Self-Introduction Guided Chat</h1>
  <div id="taskContainer"></div>

  <!-- Dictionary popup -->
  <div id="dictionaryPopup" class="popup">
    <h4 id="dictWord">Word</h4>
    <p id="dictDefinition" style="margin:0 0 8px;">Definition goes here...</p>
    <div style="display:flex; gap:8px; flex-wrap:wrap;">
      <button onclick="confirmAddToGlossary()">‚ûï Add to Glossary</button>
      <button onclick="closePopup()">‚úñ Close</button>
    </div>
  </div>

  <!-- Glossary table -->
  <table class="glossary-table" id="glossary-table">
    <thead><tr><th>Word/Phrase</th><th>Meaning</th></tr></thead>
    <tbody></tbody>
  </table>

  <!-- Save area -->
  <div style="text-align: center; margin-top: 40px;">
    <button onclick="saveAsHTML()">üíæ Save My Work (Download HTML)</button>
    <button onclick="saveTextDump()">üìù Save All Text (.txt)</button>
  </div>

  <script>
    // ============ CONFIG ============
    const API_CHAT = "https://si-ai-support.vercel.app/api/chat";

    // Minimal, friendly task prompts (unchanged logic)
    const taskPrompts = {
      1: `You are a friendly assistant helping a student build a self-introduction presentation. Ask one question at a time to gather personal profile information such as name, birthday, hometown, school, hobbies, and favorite things. React warmly after each answer. If the English has small mistakes or sounds unnatural, gently suggest a clearer or more natural version, like 'You could also say: ...'. Avoid giving multiple questions at once. After gathering 7‚Äì9 items, say: 'Great job! You‚Äôve finished Task 1. Let‚Äôs move on when you‚Äôre ready.'`,

      2: `You are continuing to help the student. This time, guide them to reflect on their personality using simple yes/no questions, one at a time, like in an MTGI test. Be supportive and help them express themselves in basic English. After each answer, react naturally and suggest clearer phrasing when necessary. Do not list all questions at once. After 8‚Äì10 questions, summarize their personality using 3‚Äì5 traits (e.g., calm, curious, detail-oriented). Make it clear when the task is complete. The result will be used later to create Slide 3: My Personality Analysis.`,

      3: `You are helping the student discover their core message and presentation theme. Begin by asking them to talk about their interests or what they like to do. Ask one open-ended question at a time, using simple language and giving relatable examples (e.g., drawing, helping others, cooking, etc.). React supportively and ask follow-up questions as needed. Suggest a few possible themes based on what they share, such as 'Creative spirit with quiet confidence' or 'Sports lover with leadership dreams'. Be sure to keep the tone encouraging and conversational.`,

      4: `Help the student turn their answers into a self-introduction presentation.
STRICT RULES:
 - Do NOT re-ask questions already covered in Tasks 1‚Äì3 (profile, personality, theme).
 - Use only the provided context. If an essential single field is missing for a slide, ask a SINGLE, targeted, fill-in-the-blank question prefixed with "Missing:"  (e.g., "Missing: Birthday (YYYY-MM-DD)"). Never ask open-ended repeats.

OUTPUT:
 - Create a 5‚Äì7 slide outline. Titles + bullet content only (no narration).
 - Slide 1: a table with fields: Name, Birthday, Hometown, Others (left) ‚Üí answers (right).
 - Slide 2: keywords only (e.g., Calm / Curious / Independent).
 - Slides 3‚Äì5+: use the student‚Äôs theme/interests from Task 3.

END:
 - Ask: "Would you like to move on to the narration practice next?"`,

      5: `Work with the student to refine their presentation narration. Use the slides created in Task 4 and go through them one by one. For each slide, ask the student: 'What would you like to say for this slide?' Then help them write a natural-sounding narration, improving clarity and flow while keeping their personality and style. Give encouragement and clear suggestions. When all slides are covered, confirm: 'That‚Äôs a great draft! Would you like to practice reading it out loud or revise anything?'`
    };

    const starterUserMessages = {
      1: "Let's begin Task 1. Please start asking questions to gather profile information.",
      2: "Let‚Äôs begin Task 2. Please start with personality-related questions.",
      3: "Let‚Äôs begin Task 3. Please ask what has influenced the student.",
      4: "Let‚Äôs begin Task 4. Help the student build their slides.",
      5: "Let‚Äôs begin Task 5. Help the student refine their final script."
    };

    // Titles + hints shown in UI only
    const taskTitles = {
      1: "Task 1: Profile Information",
      2: "Task 2: Personality Analysis",
      3: "Task 3: Discover Your Theme",
      4: "Task 4: Slide Planning",
      5: "Task 5: Narration Practice"
    };
    const taskHints = {
      1: "Collect your name, birthday, hometown, school, hobbies, and favorites.",
      2: "Answer simple yes/no questions. We‚Äôll summarize your traits as keywords.",
      3: "Share interests and experiences. We‚Äôll choose a theme for your story.",
      4: "Build slides from previous tasks. Tip: when the outline looks good, type: ‚ÄúPlease draft narration for all slides.‚Äù",
      5: "We‚Äôll refine the narration for each slide. You can read aloud or tweak wording together."
    };

    // State
    let chatHistories = {};
    let studentContext = {}; // persisted in Save HTML

    // ============ TASK UI ============
    function createTask(taskNum, title, hint) {
      const container = document.getElementById("taskContainer");
      const section = document.createElement("div");
      section.className = "section";
      section.innerHTML = `
        <h2>${title}</h2>
        <p class="hint">${hint}</p>
        <button onclick="startTask(${taskNum})">Start Task ${taskNum}</button>
        <button onclick="resetTask(${taskNum})" style="margin-left: 10px; background-color: #e74c3c;">üóë Reset</button>
        <div id="chat${taskNum}" class="chat-box" style="display:none;"></div>
        <textarea id="input${taskNum}" placeholder="Type here..." style="display:none;"></textarea><br>
        <button id="send${taskNum}" style="display:none;" onclick="sendToGPT(${taskNum})">Send</button>
        <button onclick="lookupSelectedText()" style="margin-top:10px; background-color: #f39c12;">üìñ What does it mean?</button>
      `;
      container.appendChild(section);
    }

    function resetTask(taskNum) {
      document.getElementById(`chat${taskNum}`).innerText = "";
      document.getElementById(`input${taskNum}`).value = "";
      document.getElementById(`chat${taskNum}`).style.display = "none";
      document.getElementById(`input${taskNum}`).style.display = "none";
      document.getElementById(`send${taskNum}`).style.display = "none";
      delete chatHistories[taskNum];
    }

    // ===== Helpers for Task 4 context & Task 5 carryover (non-invasive) =====
    function extractLastAssistantText(taskNum) {
      const arr = (chatHistories[taskNum] || []).slice().reverse();
      const found = arr.find(m => m.role === "assistant");
      return found ? found.content : "";
    }
    function extractUserAnswers(taskNum, limit = 12) {
      const arr = (chatHistories[taskNum] || []).filter(m => m.role === "user").map(m => m.content);
      return arr.slice(-limit);
    }
    function buildTask4Context() {
      const profileRaw = extractUserAnswers(1, 12);
      const traits = extractLastAssistantText(2);
      const theme  = extractLastAssistantText(3);

      const parts = [];
      parts.push("CONTEXT FROM TASKS 1‚Äì3 (for Task 4). Do NOT re-ask previously covered questions.");
      if (profileRaw.length) {
        parts.push("\nProfile answers (raw):");
        profileRaw.forEach((a, i) => parts.push(`- ${a}`));
      }
      if (traits) {
        parts.push("\nPersonality summary (Task 2):");
        parts.push(traits);
      }
      if (theme) {
        parts.push("\nTheme / interests (Task 3):");
        parts.push(theme);
      }
      parts.push("\nIf an essential single field for Slide 1 is missing, ask ONE targeted fill-in question prefixed with 'Missing:' (e.g., 'Missing: Birthday (YYYY-MM-DD)'). Never ask open-ended repeats.");
      return parts.join("\n");
    }
    function prefillTask5FromTask4() {
      const lastAssistant = extractLastAssistantText(4);
      if (!lastAssistant) return;
      chatHistories[5] = chatHistories[5] || [{ role: "system", content: taskPrompts[5] }];
      const already = chatHistories[5].some(m => m.role === "assistant" && m.content.includes("Here is your narration draft carried over"));
      if (!already) {
        chatHistories[5].push({
          role: "assistant",
          content: "Here is your narration draft carried over from Task 4:\n\n" + lastAssistant
        });
      }
    }

    // ============ START / SEND ============
    async function startTask(taskNum) {
      const chatBox = document.getElementById(`chat${taskNum}`);
      const inputBox = document.getElementById(`input${taskNum}`);
      const sendBtn = document.getElementById(`send${taskNum}`);
      chatBox.style.display = inputBox.style.display = sendBtn.style.display = "block";

      // Auto-carry narration from Task 4 -> Task 5 on first open
      if (taskNum === 5 && (!chatHistories[5] || chatHistories[5].filter(m => m.role !== "system").length === 0)) {
        prefillTask5FromTask4();
      }

      if (Array.isArray(chatHistories[taskNum]) && chatHistories[taskNum].length > 0) {
        chatBox.innerText = chatHistories[taskNum]
          .filter(m => m.role === "user" || m.role === "assistant")
          .map(m => `${m.role === "user" ? "You" : "ChatGPT"}: ${m.content}`)
          .join("\n\n");
        return;
      }

      chatBox.innerText = "‚è≥ Loading...";
      chatHistories[taskNum] = [{ role: "system", content: taskPrompts[taskNum] }];

      // Inject non-invasive context for Task 4 so it doesn't re-ask
      if (taskNum === 4) {
        const ctx = buildTask4Context();
        if (ctx.trim()) {
          chatHistories[taskNum].push({ role: "system", content: ctx });
          studentContext.lastTask4Context = ctx; // for Save HTML / debug
        }
      }

      chatHistories[taskNum].push({ role: "user", content: starterUserMessages[taskNum] });

      try {
        const res = await fetch(API_CHAT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ model: "gpt-4o", messages: chatHistories[taskNum] })
        });
        const data = await res.json();
        const message = data.choices?.[0]?.message;
        if (message) chatHistories[taskNum].push(message);

        chatBox.innerText = chatHistories[taskNum]
          .filter(m => m.role === "user" || m.role === "assistant")
          .map(m => `${m.role === "user" ? "You" : "ChatGPT"}: ${m.content}`)
          .join("\n\n");
      } catch (err) {
        chatBox.innerText = "‚ùå Failed to load response.";
      }
    }

    async function sendToGPT(taskNum) {
      const inputBox = document.getElementById(`input${taskNum}`);
      const chatBox = document.getElementById(`chat${taskNum}`);
      const userMessage = inputBox.value.trim();
      if (!userMessage) return;
      inputBox.value = "";
      chatHistories[taskNum].push({ role: "user", content: userMessage });

      try {
        const res = await fetch(API_CHAT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ model: "gpt-4o", messages: chatHistories[taskNum] })
        });
        const data = await res.json();
        const message = data.choices?.[0]?.message;
        if (message) chatHistories[taskNum].push(message);

        // render
        chatBox.innerText = chatHistories[taskNum]
          .filter(m => m.role === "user" || m.role === "assistant")
          .map(m => `${m.role === "user" ? "You" : "ChatGPT"}: ${m.content}`)
          .join("\n\n");
      } catch (err) {
        chatBox.innerText += "\n‚ùå Failed to get response.";
      }
    }

    // ============ DICTIONARY ============
    async function lookupSelectedText() {
      const text = window.getSelection().toString().trim();
      if (!text) { alert("Please highlight a word or phrase first."); return; }

      const popup = document.getElementById('dictionaryPopup');
      const dictWord = document.getElementById('dictWord');
      const dictDefinition = document.getElementById('dictDefinition');

      dictWord.innerText = text;
      dictDefinition.innerText = '‚è≥ Loading...';
      popup.style.display = 'block';

      try {
        const res = await fetch(API_CHAT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ model: "gpt-4o", messages: [
            { role: "system", content: "You are a helpful dictionary assistant." },
            { role: "user", content: `Define "${text}" simply for a Japanese student.` }
          ] })
        });
        const data = await res.json();
        const definition = data.choices?.[0]?.message?.content || 'No definition found.';

        const jpRes = await fetch(API_CHAT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ model: "gpt-4o", messages: [
            { role: "system", content: "You are a Japanese academic assistant." },
            { role: "user", content: `Êó•Êú¨Ë™û„ÅßÁ∞°Âçò„Å´„Äå${text}„Äç„ÅÆÊÑèÂë≥„ÇíË™¨Êòé„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºàÂ§ßÂ≠¶ÁîüÂêë„ÅëÔºâ„ÄÇ` }
          ] })
        });
        const jpData = await jpRes.json();
        const jpMeaning = jpData.choices?.[0]?.message?.content || '';

        dictDefinition.innerHTML = `${definition}<br><br><em>ÔºàÊó•Êú¨Ë™û„ÅÆÊÑèÂë≥Ôºâ</em> ${jpMeaning}`;
      } catch (err) {
        dictDefinition.innerText = `Error: ${err.message}`;
      }

      // Ensure visible on open if too tall
      requestAnimationFrame(() => {
        const rect = popup.getBoundingClientRect();
        if (rect.bottom > window.innerHeight) {
          popup.style.top = Math.max(8, window.innerHeight - rect.height - 8) + 'px';
          popup.style.right = 'auto';
          popup.style.left = Math.max(8, window.innerWidth - rect.width - 8) + 'px';
        }
      });
    }

    function confirmAddToGlossary() {
      const word = document.getElementById('dictWord').innerText;
      const def = document.getElementById('dictDefinition').innerHTML;
      const row = document.createElement('tr');
      row.innerHTML = `<td>${word}</td><td>${def}</td>`;
      document.querySelector('#glossary-table tbody').appendChild(row);
      closePopup();
    }
    function closePopup() { document.getElementById('dictionaryPopup').style.display = 'none'; }

    // Enable dragging the dictionary popup by its title (h4#dictWord)
    function enablePopupDrag() {
      const popup  = document.getElementById('dictionaryPopup');
      const handle = document.getElementById('dictWord');
      if (!popup || !handle) return;

      let dragging = false, startX = 0, startY = 0, startLeft = 0, startTop = 0;

      handle.addEventListener('mousedown', (e) => {
        dragging = true;
        const rect = popup.getBoundingClientRect();
        popup.style.left = rect.left + 'px';
        popup.style.top  = rect.top  + 'px';
        popup.style.right = 'auto'; // switch to left/top positioning while dragging
        startX = e.clientX; startY = e.clientY;
        startLeft = rect.left; startTop = rect.top;
        document.body.style.userSelect = 'none';
      });

      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        let nextLeft = startLeft + dx;
        let nextTop  = startTop  + dy;

        // keep within viewport
        const pad = 8;
        const ww = window.innerWidth, wh = window.innerHeight;
        const r  = popup.getBoundingClientRect();
        const w  = r.width, h = r.height;

        nextLeft = Math.min(Math.max(pad, nextLeft), ww - w - pad);
        nextTop  = Math.min(Math.max(pad, nextTop),  wh - h - pad);

        popup.style.left = nextLeft + 'px';
        popup.style.top  = nextTop  + 'px';
      });

      window.addEventListener('mouseup', () => {
        dragging = false;
        document.body.style.userSelect = '';
      });
    }
    document.addEventListener('DOMContentLoaded', enablePopupDrag);

    // ============ SAVE-AS-HTML ============
    function saveAsHTML() {
      const state = { chatHistories, studentContext };
      const stateJSON = JSON.stringify(state);
      const stateScript = `<script>window.SAVED_STATE=${stateJSON}<\/script>`;
      const html = document.documentElement.outerHTML.replace(/<\/body>\s*<\/html>\s*$/i, `${stateScript}\n</body></html>`);
      const blob = new Blob([html], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `SelfIntro_${new Date().toISOString().slice(0,10)}.html`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // ============ SAVE TEXT (.txt) ============
    function saveTextDump() {
      const lines = [];
      for (let i = 1; i <= 5; i++) {
        const hist = chatHistories[i] || [];
        if (!hist.length) continue;
        lines.push(`==== Task ${i} ====`);
        hist
          .filter(m => m.role === "user" || m.role === "assistant")
          .forEach(m => lines.push(`${m.role === "user" ? "You" : "ChatGPT"}: ${m.content}`));
        lines.push("");
      }
      if (typeof studentContext === "object" && studentContext) {
        lines.push("==== Context ====");
        try { lines.push(JSON.stringify(studentContext, null, 2)); } catch {}
        lines.push("");
      }
      const blob = new Blob([lines.join("\n")], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `SelfIntro_${new Date().toISOString().slice(0,10)}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // ============ INIT ============
    createTask(1, taskTitles[1], taskHints[1]);
    createTask(2, taskTitles[2], taskHints[2]);
    createTask(3, taskTitles[3], taskHints[3]);
    createTask(4, taskTitles[4], taskHints[4]);
    createTask(5, taskTitles[5], taskHints[5]);

    // Restore if saved HTML has embedded state
    if (window.SAVED_STATE) {
      chatHistories = window.SAVED_STATE.chatHistories || {};
      studentContext = window.SAVED_STATE.studentContext || {};

      Object.keys(chatHistories).forEach((taskNum) => {
        const chatBox = document.getElementById(`chat${taskNum}`);
        const inputBox = document.getElementById(`input${taskNum}`);
        const sendBtn = document.getElementById(`send${taskNum}`);
        const startBtn = document.querySelector(`button[onclick="startTask(${taskNum})"]`);

        if (!chatBox || !inputBox || !sendBtn) return;

        // Show inputs
        chatBox.style.display = inputBox.style.display = sendBtn.style.display = "block";

        // Restore messages
        chatBox.innerText = chatHistories[taskNum]
          .filter(m => m.role === "user" || m.role === "assistant")
          .map(m => `${m.role === "user" ? "You" : "ChatGPT"}: ${m.content}`)
          .join("\n\n");

        // Rebind send button to continue
        sendBtn.onclick = () => sendToGPT(Number(taskNum));

        // Disable "Start Task" so it doesn't reset history
        if (startBtn) {
          startBtn.disabled = true;
          startBtn.textContent = `Task ${taskNum} (restored)`;
        }
      });
    }
  </script>
</body>
</html>